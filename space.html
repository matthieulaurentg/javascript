import React, { useState, useEffect, useCallback } from 'react';

const GAME_WIDTH = 300;
const GAME_HEIGHT = 400;

const DIFFICULTY_SETTINGS = {
  EASY: { initialSpeed: 0.5, speedIncrease: 0.1, spawnRate: 0.01 },
  HARD: { initialSpeed: 1, speedIncrease: 0.2, spawnRate: 0.02 },
  EXTREME: { initialSpeed: 1.5, speedIncrease: 0.3, spawnRate: 0.03 }
};

const SpaceInvaders = () => {
  const [difficulty, setDifficulty] = useState(null);
  const [playerPosition, setPlayerPosition] = useState(GAME_WIDTH / 2);
  const [bullets, setBullets] = useState([]);
  const [enemies, setEnemies] = useState([]);
  const [score, setScore] = useState(0);
  const [wave, setWave] = useState(1);
  const [gameStarted, setGameStarted] = useState(false);
  const [gameOver, setGameOver] = useState(false);

  const startGame = (selectedDifficulty) => {
    setDifficulty(selectedDifficulty);
    setGameStarted(true);
    setGameOver(false);
    setScore(0);
    setWave(1);
    setEnemies([]);
    setBullets([]);
    setPlayerPosition(GAME_WIDTH / 2);
  };

  const movePlayer = useCallback((e) => {
    if (e.key === 'ArrowLeft' || e.key === 'a') {
      setPlayerPosition(prev => Math.max(20, prev - 10));
    } else if (e.key === 'ArrowRight' || e.key === 'd') {
      setPlayerPosition(prev => Math.min(GAME_WIDTH - 20, prev + 10));
    } else if (e.key === ' ' || e.key === 'w') {
      setBullets(prev => [...prev, { x: playerPosition, y: GAME_HEIGHT - 40 }]);
    }
  }, [playerPosition]);

  const handleTouchMove = useCallback((e) => {
    const touch = e.touches[0];
    const gameRect = e.currentTarget.getBoundingClientRect();
    const newPosition = touch.clientX - gameRect.left;
    setPlayerPosition(Math.max(20, Math.min(GAME_WIDTH - 20, newPosition)));
  }, []);

  const handleTouchStart = useCallback(() => {
    setBullets(prev => [...prev, { x: playerPosition, y: GAME_HEIGHT - 40 }]);
  }, [playerPosition]);

  useEffect(() => {
    if (gameStarted && !gameOver) {
      window.addEventListener('keydown', movePlayer);
      return () => window.removeEventListener('keydown', movePlayer);
    }
  }, [movePlayer, gameStarted, gameOver]);

  useEffect(() => {
    if (!gameStarted || gameOver) return;

    const gameLoop = setInterval(() => {
      // Move bullets
      setBullets(prev => prev.map(bullet => ({ ...bullet, y: bullet.y - 5 })).filter(bullet => bullet.y > 0));

      // Move enemies
      setEnemies(prev => {
        const enemySpeed = DIFFICULTY_SETTINGS[difficulty].initialSpeed + (wave - 1) * DIFFICULTY_SETTINGS[difficulty].speedIncrease;
        const newEnemies = prev.map(enemy => ({ ...enemy, y: enemy.y + enemySpeed }));
        if (Math.random() < DIFFICULTY_SETTINGS[difficulty].spawnRate) {
          newEnemies.push({ x: Math.random() * (GAME_WIDTH - 40) + 20, y: 0 });
        }
        return newEnemies;
      });

      // Check collisions
      setBullets(prev => {
        const newBullets = [...prev];
        setEnemies(prevEnemies => {
          const newEnemies = prevEnemies.filter(enemy => {
            const hitByBullet = newBullets.find(bullet => 
              Math.abs(bullet.x - enemy.x) < 20 && Math.abs(bullet.y - enemy.y) < 20
            );
            if (hitByBullet) {
              const bulletIndex = newBullets.indexOf(hitByBullet);
              newBullets.splice(bulletIndex, 1);
              setScore(s => s + 10);
              return false;
            }
            return true;
          });
          return newEnemies;
        });
        return newBullets;
      });

      // Check for game over
      setEnemies(prevEnemies => {
        if (prevEnemies.some(enemy => enemy.y > GAME_HEIGHT - 40)) {
          setGameOver(true);
        }
        return prevEnemies;
      });

      // Check for next wave
      if (enemies.length === 0) {
        setWave(w => w + 1);
      }
    }, 50);

    return () => clearInterval(gameLoop);
  }, [difficulty, wave, gameStarted, gameOver]);

  const PlayerShip = ({ x }) => (
    <svg x={x - 20} y={GAME_HEIGHT - 40} width="40" height="40" viewBox="0 0 40 40">
      <path d="M20 0 L40 40 L0 40 Z" fill="blue" />
    </svg>
  );

  const EnemyShip = ({ x, y }) => (
    <svg x={x - 20} y={y} width="40" height="40" viewBox="0 0 40 40">
      <path d="M0 40 L20 0 L40 40 Z" fill="red" />
    </svg>
  );

  const Bullet = ({ x, y }) => (
    <circle cx={x} cy={y} r="3" fill="yellow" />
  );

  if (!gameStarted || gameOver) {
    return (
      <div className="w-full h-full bg-black flex flex-col justify-center items-center text-white">
        <h2 className="text-2xl mb-4">Space Invaders</h2>
        {gameOver && <p className="mb-4">Game Over! Score: {score}</p>}
        <button onClick={() => startGame('EASY')} className="m-2 px-4 py-2 bg-green-500 text-white rounded">Easy</button>
        <button onClick={() => startGame('HARD')} className="m-2 px-4 py-2 bg-yellow-500 text-white rounded">Hard</button>
        <button onClick={() => startGame('EXTREME')} className="m-2 px-4 py-2 bg-red-500 text-white rounded">Extreme</button>
      </div>
    );
  }

  return (
    <div 
      className="w-full h-full bg-black relative overflow-hidden"
      style={{ maxWidth: GAME_WIDTH, maxHeight: GAME_HEIGHT }}
      onTouchMove={handleTouchMove}
      onTouchStart={handleTouchStart}
    >
      <svg width="100%" height="100%" viewBox={`0 0 ${GAME_WIDTH} ${GAME_HEIGHT}`}>
        <PlayerShip x={playerPosition} />
        {bullets.map((bullet, index) => (
          <Bullet key={index} x={bullet.x} y={bullet.y} />
        ))}
        {enemies.map((enemy, index) => (
          <EnemyShip key={index} x={enemy.x} y={enemy.y} />
        ))}
      </svg>
      <div className="absolute top-2 left-2 text-white">Score: {score}</div>
      <div className="absolute top-8 left-2 text-white">Wave: {wave}</div>
      <div className="absolute top-14 left-2 text-white">Difficulty: {difficulty}</div>
      {gameOver && (
        <div className="absolute inset-0 bg-black bg-opacity-75 flex items-center justify-center">
          <div className="text-white text-2xl">Game Over!</div>
        </div>
      )}
    </div>
  );
};

export default SpaceInvaders;